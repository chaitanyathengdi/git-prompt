# format: <U M A> <branch name/HEAD detached at> <7 char commit hash> <prompt>
function _git_prompt() {

    local git_status="`git status -unormal 2>&1`"
    local git_log="`git log 2>&1`"

    #detect git repo
    if ! [[ "$git_status" =~ Not\ a\ git\ repository || "$git_status" =~ Unable\ to\ read\ current\ working\ directory ]]; then

        # Untracked files
        if [[ "$git_status" =~ Untracked\ files\: ]]; then
            local UNTRACKED="\[\e[1;31;49m\]U\[\e[0m\] "
        fi

        # Added files to index
        if [[ "$git_status" =~ Changes\ to\ be\ committed\: ]]; then
            local ADDED="\[\e[1;32;49m\]A\[\e[0m\] "
            #Detect a rebase ready to go
            if [[ "$git_status" =~ \(all\ conflicts\ fixed\: ]]; then
                local MERGING=""
                local REBASING="\[\e[1;32;49m\]Rbs\[\e[0m\] "
            fi
            #Detect a finished merge
            if [[ "$git_status" =~ \(use\ \"git\ commit\"\ to\ conclude\ merge\) ]]; then
                local REBASING=""
                local MERGING="\[\e[1;32;49m\]Mrg\[\e[0m\] "
            fi
        fi

        # Modified files
        if [[ "$git_status" =~ Changes\ not\ staged ]]; then
            local MODIFIED="\[\e[1;31;49m\]M\[\e[0m\] "
        fi

        # Detect branch
        if [[ "$git_status" =~ On\ branch\ ([^[:space:]]+) ]]; then
            local BRANCH="${BASH_REMATCH[1]}"
        else
            local HEAD_DETACHED_AT="\[\e[1;31;49m\]HEAD detached at\[\e[0m\] "
            BRANCH=""
        fi
        if [[ "$git_log" =~ does\ not\ have\ any\ commits\ yet ]]; then
            local HASH="0000000"
        else
            # detect hash of HEAD
            local HASH="`git rev-parse HEAD`"
            HASH="\[\e[38;5;136m\]${HASH:0:7}\[\e[0m\]"
        fi

        # Detect ahead/behind origin
        if [[ "$BRANCH" != "" ]]; then
            local ORIGIN=`git remote`
            if [[ "$ORIGIN" != "" ]]; then        # not valid if no origin
                ORIGIN=($ORIGIN);ORIGIN=${ORIGIN[0]} # take first remote only, for now
                if [[ `git branch -r | grep $ORIGIN/$BRANCH` != "" ]]; then    # check only branches that have remote counterparts
                    local commitsAhead=`git log --pretty=oneline $ORIGIN/$BRANCH..$BRANCH | wc -l`
                    local commitsBehind=`git log --pretty=oneline $BRANCH..$ORIGIN/$BRANCH | wc -l`
                    local UPDATE=''
                    if [[ $commitsAhead -eq 0 ]]; then # origin is either up-to-date or ahead
                        if [[ $commitsBehind -eq 0 ]]; then # you are up to date
                            UPDATE=""
                        else
                            UPDATE=" \[\e[1;34;49m\]-$commitsBehind\[\e[0m\] "
                        fi
                    else
                        UPDATE=" \[\e[1;32;49m\]+$commitsAhead\[\e[0m\] "
                    fi
                fi
            fi
        fi

        #Detect merge conflicts
        if [[ "$git_status" =~ Unmerged\ paths\: ]]; then
            local CONFLICTS="\[\e[1;31;49m\]C\[\e[0m\] "
        fi

        #Detect an unfinished merge
        if [[ "$git_status" =~ fix\ conflicts\ and\ run\ \"git\ commit\" ]]; then
            local REBASING=""
            local MERGING="\[\e[1;31;49m\]Mrg\[\e[0m\] "
        fi

        #Detect conflicting rebase
        if [[ "$git_status" =~ \(fix\ conflicts\ and\ then\ run\ \"git\ rebase\ \-\-continue\"\) ]]; then
            local MERGING=""
            local REBASING="\[\e[1;31;49m\]Rbs\[\e[0m\] "
        fi


        # Output
        if [[ "$BRANCH" != "" ]]; then BRANCH="$BRANCH:"; fi
        echo -n "$CONFLICTS$UNTRACKED$MODIFIED$ADDED$MERGING$REBASING$BRANCH$HEAD_DETACHED_AT$HASH$UPDATE "
    fi
}
function _prompt_command() {
    PS1="`_git_prompt`"'\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
}
PROMPT_COMMAND=_prompt_command
